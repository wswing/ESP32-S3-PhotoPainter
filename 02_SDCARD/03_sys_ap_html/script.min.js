let ImageSysCanvas, SourcePlaceholder, InPutButton, SendButton, FileInput, BtnBgBlack, BtnBgWhite, BgColorText, AlgoToggle;
let cropBox, imageWrapper;
let cropState = {
    isDragging: false,
    isResizing: false,
    isPanning: false,
    resizeHandle: null,
    startX: 0,
    startY: 0,
    startLeft: 0,
    startTop: 0,
    startWidth: 0,
    startHeight: 0,
    imgNaturalWidth: 0,
    imgNaturalHeight: 0,
    scaleX: 1,
    scaleY: 1,
    boxLeft: 0,
    boxTop: 0,
    boxWidth: 0,
    boxHeight: 0,
    realX: 0,
    realY: 0,
    realW: 0,
    realH: 0,
    renderLeftOff: 0,
    renderTopOff: 0
};
let processedCanvas = null; // Memory cache for the latest processed image数据
let SrcRotateLBtn, SrcRotateRBtn, SrcMirrorBtn, ZoomInBtn, ZoomOutBtn, RatioDropdownBtn, RatioMenu;
let modeButtons, tips;
let currentMode = 'AP';
let processedBase64 = "";
let fileFlag = 0;
let currentRatio = 5 / 3; // Default 5:3, can be 'free'
let targetW = 800, targetH = 480, screenOrientation = 'landscape';
let OrientationToggle;

// Source manipulation state
let originalImage = new Image();
let sourceRotateAngle = 0; // 0, 90, 180, 270
let isMirrored = false;
let imageScale = 1.0; // Zoom scale, 1.0 = 100%
let baseFitScale = 1.0; // Auto-calculated fit scale
let imgPanX = 0, imgPanY = 0; // Panning offsets
const MIN_SCALE = 0.1; // Minimum 10%
const MAX_SCALE = 5.0; // Maximum 500%
const ZOOM_FACTOR = 1.1; // 10% zoom per step (multiplicative)

function updateModeByValue(targetMode) {
    const validModes = ['AP', 'STA'];
    if (!validModes.includes(targetMode)) {
        console.warn('Invalid mode value. Using default AP mode.');
        targetMode = 'AP';
    }

    const activeButton = document.querySelector(`a[data-mode="${targetMode}"]`);
    if (activeButton) {
        modeButtons.forEach(btn => btn.classList.remove('active'));
        activeButton.classList.add('active');
        currentMode = targetMode;
        updateTips();
    }
}

function initializeMode() {
    updateModeByValue('AP');
}

function updateTips() {
    tips.forEach(tip => tip.classList.remove('d-none'));
    if (currentMode === "AP") {
        document.getElementById('tips-STA')?.classList.add('d-none');
    } else {
        document.getElementById('tips-AP')?.classList.add('d-none');
    }
}

function applyScreenOrientation(orient) {
    if (orient === 'portrait') {
        screenOrientation = 'portrait';
        targetW = 480;
        targetH = 800;
        const orientText = document.getElementById("Orientation_Text");
        if (orientText) orientText.textContent = "Portrait";
        if (currentRatio === 5 / 3 || currentRatio === 'free') {
            currentRatio = 3 / 5;
            updateRatioButtonText();
        }
    } else {
        screenOrientation = 'landscape';
        targetW = 800;
        targetH = 480;
        const orientText = document.getElementById("Orientation_Text");
        if (orientText) orientText.textContent = "Landscape";
        if (currentRatio === 3 / 5 || currentRatio === 'free') {
            currentRatio = 5 / 3;
            updateRatioButtonText();
        }
    }
    // Reset panning on orientation change
    imgPanX = 0; imgPanY = 0;
}

function refreshProcessedImage() {
    if (!fileFlag) return;
    if (AlgoToggle && AlgoToggle.checked) processCroppedImageE6();
    else processCroppedImage();
}

function Even_init() {
    InPutButton = document.getElementById("Input_Button");
    SendButton = document.getElementById("Send_Button");
    FileInput = document.getElementById("File_Input");
    ImageSysCanvas = document.getElementById("Image_Input_Canvas"); // Now a Canvas
    SourcePlaceholder = document.getElementById("Image_Placeholder");

    // New Bg Color Controls
    BtnBgBlack = document.getElementById("Btn_Bg_Black");
    BtnBgWhite = document.getElementById("Btn_Bg_White");
    BgColorText = document.getElementById("Bg_Color_Text");
    AlgoToggle = document.getElementById("Algo_Toggle");
    OrientationToggle = document.getElementById("Orientation_Toggle");

    if (AlgoToggle) {
        AlgoToggle.addEventListener('change', refreshProcessedImage);
    }

    if (OrientationToggle) {
        OrientationToggle.addEventListener('click', () => {
            applyScreenOrientation(screenOrientation === 'landscape' ? 'portrait' : 'landscape');
            if (fileFlag) initCropForImage();
        });
    }

    // Initialize E6 Sliders & Listeners
    const sliders = ["Gamma", "Contrast", "Saturation", "Dither", "Threshold"];
    sliders.forEach(name => {
        const slider = document.getElementById(`Slider_${name}`);
        const valSpan = document.getElementById(`Val_${name}`);
        if (slider && valSpan) {
            slider.addEventListener('input', () => {
                valSpan.textContent = slider.value;
            });
            slider.addEventListener('change', refreshProcessedImage);
        }
    });

    // Preset Switching Logic
    const presets = {
        natural: { Gamma: 1.1, Contrast: 0.4, Saturation: 1.2, Dither: 0.7, Threshold: 10 },
        portrait: { Gamma: 1.2, Contrast: 0.2, Saturation: 1.1, Dither: 0.5, Threshold: 15 },
        landscape: { Gamma: 1.0, Contrast: 0.6, Saturation: 1.4, Dither: 0.8, Threshold: 8 },
        art: { Gamma: 0.9, Contrast: 0.9, Saturation: 1.5, Dither: 1.0, Threshold: 5 }
    };

    document.getElementById("Preset_Group").addEventListener("click", (e) => {
        const presetKey = e.target.getAttribute("data-preset");
        if (presetKey && presets[presetKey]) {
            const config = presets[presetKey];
            for (const key in config) {
                const slider = document.getElementById(`Slider_${key}`);
                const valSpan = document.getElementById(`Val_${key}`);
                slider.value = config[key];
                valSpan.textContent = config[key];
            }
            if (AlgoToggle.checked && fileFlag) processCroppedImageE6();
            // If not in E6 mode, we still refresh to show preset values (though presets are mostly for E6)
            else refreshProcessedImage();
        }
    });

    // Ink Simulation Toggle Listener
    const inkSimToggle = document.getElementById("Ink_Sim_Toggle");
    const inkMask = document.getElementById("Ink_Simulation_Mask");
    const inkTint = document.getElementById("Ink_Simulation_Tint");
    const processedImg = document.getElementById("Image_Processed");

    if (inkSimToggle) {
        inkSimToggle.addEventListener('change', () => {
            const isActive = inkSimToggle.checked;
            if (inkMask) inkMask.classList.toggle("active", isActive);
            if (inkTint) inkTint.classList.toggle("active", isActive);
            if (processedImg) processedImg.classList.toggle("ink-sim-active", isActive);
        });
    }

    cropBox = document.getElementById("Crop_Box");
    imageWrapper = document.getElementById("Image_Wrapper");

    // New Source Control Buttons
    SrcRotateLBtn = document.getElementById("Src_Rotate_L");
    SrcRotateRBtn = document.getElementById("Src_Rotate_R");
    SrcMirrorBtn = document.getElementById("Src_Mirror");
    ZoomInBtn = document.getElementById("Zoom_In");
    ZoomOutBtn = document.getElementById("Zoom_Out");
    RatioDropdownBtn = document.getElementById("Ratio_Dropdown");
    RatioMenu = document.querySelector(".dropdown-menu");

    // Add handles
    const handles = ['nw', 'ne', 'sw', 'se'];
    handles.forEach(pos => {
        let h = document.createElement('div');
        h.className = `crop-handle handle-${pos}`;
        h.dataset.handle = pos;
        cropBox.appendChild(h);
    });

    updateRatioButtonText();

    InPutButton.addEventListener("click", InPutButton_Even);
    FileInput.addEventListener("change", FileInput_Even);
    SendButton.addEventListener("click", SendButton_Even);

    if (imageWrapper) imageWrapper.style.cursor = 'crosshair';

    // Bg Color Events
    if (BtnBgBlack) BtnBgBlack.addEventListener("click", () => setBgColor("#000000"));
    if (BtnBgWhite) BtnBgWhite.addEventListener("click", () => setBgColor("#FFFFFF"));
    if (BgColorText) BgColorText.addEventListener("input", refreshProcessedImage);

    // Source manipulation events
    if (SrcRotateLBtn) SrcRotateLBtn.addEventListener("click", () => rotateSource(-90));
    if (SrcRotateRBtn) SrcRotateRBtn.addEventListener("click", () => rotateSource(90));
    if (SrcMirrorBtn) SrcMirrorBtn.addEventListener("click", toggleMirror);
    if (ZoomInBtn) ZoomInBtn.addEventListener("click", zoomIn);
    if (ZoomOutBtn) ZoomOutBtn.addEventListener("click", zoomOut);

    // Ratio Dropdown events
    if (RatioMenu) {
        RatioMenu.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const r = e.target.dataset.ratio;
                setCropRatio(r);
            });
        });
    }

    // Crop events
    if (imageWrapper) {
        imageWrapper.addEventListener('mousedown', onMouseDown);
        imageWrapper.addEventListener('touchstart', (e) => onMouseDown(e.touches[0], e));
    }
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // Touch support (Move/End are global)
    document.addEventListener('touchmove', (e) => onMouseMove(e.touches[0], e));
    document.addEventListener('touchend', onMouseUp);

    window.addEventListener('resize', () => {
        if (fileFlag) initCropForImage();
    });
}

function setBgColor(color) {
    if (BgColorText) BgColorText.value = color;
    refreshProcessedImage();
}

function updateRatioButtonText() {
    if (!RatioDropdownBtn) return;
    let text = "Ratio: ";
    if (currentRatio === 'free') {
        text += "Free";
    } else if (Math.abs(currentRatio - 5 / 3) < 0.01) {
        text += "5:3";
    } else if (Math.abs(currentRatio - 3 / 5) < 0.01) {
        text += "3:5";
    } else if (Math.abs(currentRatio - 1) < 0.01) {
        text += "1:1";
    } else {
        text += "Custom";
    }
    RatioDropdownBtn.textContent = text;
}

function setCropRatio(r) {
    if (!fileFlag) return;

    if (r === 'free') {
        currentRatio = 'free';
    } else {
        currentRatio = parseFloat(r);
    }
    updateRatioButtonText();
    initCropForImage(); // Reset crop box to new ratio
}

function rotateSource(deg) {
    if (!fileFlag) return;
    sourceRotateAngle = (sourceRotateAngle + deg + 360) % 360;
    // Reset scale & pan to trigger auto-fit for new orientation
    baseFitScale = 1.0;
    imageScale = 1.0;
    imgPanX = 0; imgPanY = 0;
    renderSourceCanvas().then(() => initCropForImage());
}

function toggleMirror() {
    if (!fileFlag) return;
    isMirrored = !isMirrored;
    renderSourceCanvas().then(() => initCropForImage());
}

function zoomIn() {
    if (!fileFlag) return;
    imageScale = Math.min(imageScale * ZOOM_FACTOR, MAX_SCALE);
    renderSourceCanvas().then(() => initCropForImage());
}

function zoomOut() {
    if (!fileFlag) return;
    imageScale = Math.max(imageScale / ZOOM_FACTOR, MIN_SCALE);
    renderSourceCanvas().then(() => initCropForImage());
}

function renderSourceCanvas() {
    return new Promise((resolve) => {
        if (!originalImage.src) {
            resolve();
            return;
        }

        const canvas = ImageSysCanvas;
        const ctx = canvas.getContext('2d');

        // Determine dims based on rotation
        let targetW = originalImage.naturalWidth;
        let targetH = originalImage.naturalHeight;

        if (sourceRotateAngle % 180 !== 0) {
            targetW = originalImage.naturalHeight;
            targetH = originalImage.naturalWidth;
        }

        // Calculate fit scale if this is initial load (imageScale === 1.0 and baseFitScale === 1.0)
        if (imageScale === 1.0 && baseFitScale === 1.0) {
            const wrapperRect = imageWrapper.getBoundingClientRect();
            const fitScaleW = wrapperRect.width / targetW;
            const fitScaleH = wrapperRect.height / targetH;
            baseFitScale = Math.min(fitScaleW, fitScaleH, 1.0); // Don't upscale, max 1.0
            imageScale = baseFitScale;
        }

        // Apply zoom scale
        canvas.width = targetW * imageScale;
        canvas.height = targetH * imageScale;

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        if (isMirrored) {
            ctx.scale(-1, 1);
        }
        ctx.rotate(sourceRotateAngle * Math.PI / 180);

        // Scale the image to match the canvas size
        const scaledW = originalImage.naturalWidth * imageScale;
        const scaledH = originalImage.naturalHeight * imageScale;
        ctx.drawImage(originalImage, -scaledW / 2, -scaledH / 2, scaledW, scaledH);
        ctx.restore();

        updateCanvasPosition();
        resolve();
    });
}

function updateCanvasPosition() {
    if (ImageSysCanvas) {
        // We use translate(-50%, -50%) for centering, then add our pan offsets
        ImageSysCanvas.style.transform = `translate(calc(-50% + ${imgPanX}px), calc(-50% + ${imgPanY}px))`;
    }
}

function initCropForImage() {
    // img is now ImageSysCanvas
    const canvas = ImageSysCanvas;
    if (canvas.width === 0 || canvas.height === 0) return;

    cropState.imgNaturalWidth = canvas.width;
    cropState.imgNaturalHeight = canvas.height;

    // Get displayed dimensions directly from the element
    const rect = canvas.getBoundingClientRect();
    const wrapperRect = imageWrapper.getBoundingClientRect();

    // rect gives the actual painted area + offsets
    const renderW = rect.width;
    const renderH = rect.height;

    // Calculate offsets relative to the wrapper
    const renderLeft = rect.left - wrapperRect.left;
    const renderTop = rect.top - wrapperRect.top;

    cropState.scaleX = renderW / canvas.width;
    cropState.scaleY = renderH / canvas.height;
    cropState.renderLeftOff = renderLeft;
    cropState.renderTopOff = renderTop;

    // Initialize crop box size - maximize to fill visible area while maintaining ratio
    let targetRatio = currentRatio === 'free' ? targetW / targetH : currentRatio;
    const imgRatio = canvas.width / canvas.height;

    // Max real dimensions that would fit on screen (wrapper)
    const maxRealW = wrapperRect.width / cropState.scaleX;
    const maxRealH = wrapperRect.height / cropState.scaleY;

    // Choose the dimension that allows maximum crop box size within VISIBLE area
    if (imgRatio > targetRatio) {
        // Target is taller than image or wide enough
        cropState.realH = Math.min(canvas.height, maxRealH);
        cropState.realW = Math.ceil(cropState.realH * targetRatio);
        // If the resulting width still exceeds visible area, shrink further
        if (cropState.realW > maxRealW) {
            cropState.realW = maxRealW;
            cropState.realH = Math.ceil(cropState.realW / targetRatio);
        }
    } else {
        // Target is wider than image or tall enough
        cropState.realW = Math.min(canvas.width, maxRealW);
        cropState.realH = Math.ceil(cropState.realW / targetRatio);
        // If the resulting height still exceeds visible area, shrink further
        if (cropState.realH > maxRealH) {
            cropState.realH = maxRealH;
            cropState.realW = Math.ceil(cropState.realH * targetRatio);
        }
    }

    // Center the crop box (use floor to avoid overflow)
    cropState.realX = Math.floor((canvas.width - cropState.realW) / 2);
    cropState.realY = Math.floor((canvas.height - cropState.realH) / 2);

    cropBox.style.display = 'block';

    updateCropUI();
    refreshProcessedImage();
}

function updateCropUI() {
    cropState.boxWidth = cropState.realW * cropState.scaleX;
    cropState.boxHeight = cropState.realH * cropState.scaleY;
    cropState.boxLeft = cropState.realX * cropState.scaleX + cropState.renderLeftOff;
    cropState.boxTop = cropState.realY * cropState.scaleY + cropState.renderTopOff;

    cropBox.style.width = `${cropState.boxWidth}px`;
    cropBox.style.height = `${cropState.boxHeight}px`;
    cropBox.style.left = `${cropState.boxLeft}px`;
    cropBox.style.top = `${cropState.boxTop}px`;
}

function onMouseDown(e, originalEvent) {
    if (!fileFlag) return;
    if (originalEvent) originalEvent.preventDefault();
    else e.preventDefault();

    const target = originalEvent ? originalEvent.target : e.target;

    if (target.classList.contains('crop-handle')) {
        cropState.isResizing = true;
        cropState.resizeHandle = target.dataset.handle;
    } else if (target === cropBox || cropBox.contains(target)) {
        cropState.isDragging = true;
    } else {
        // Panning the image
        cropState.isPanning = true;
        imageWrapper.style.cursor = 'grabbing';
    }

    cropState.startX = e.clientX;
    cropState.startY = e.clientY;
    cropState.startLeft = cropState.boxLeft;
    cropState.startTop = cropState.boxTop;
    cropState.startWidth = cropState.boxWidth;
    cropState.startHeight = cropState.boxHeight;
}

function onMouseMove(e, originalEvent) {
    if (!cropState.isDragging && !cropState.isResizing && !cropState.isPanning) return;
    if (originalEvent) originalEvent.preventDefault();
    else e.preventDefault();

    const dx = e.clientX - cropState.startX;
    const dy = e.clientY - cropState.startY;

    // Allow crop box to move within entire container
    const wrapperRect = imageWrapper.getBoundingClientRect();
    const minLeft = 0;
    const maxLeft = wrapperRect.width;
    const minTop = 0;
    const maxTop = wrapperRect.height;

    if (cropState.isDragging) {
        let newLeft = cropState.startLeft + dx;
        let newTop = cropState.startTop + dy;

        const maxBoxLeft = maxLeft - cropState.boxWidth;
        const maxBoxTop = maxTop - cropState.boxHeight;

        newLeft = Math.max(minLeft, Math.min(newLeft, maxBoxLeft));
        newTop = Math.max(minTop, Math.min(newTop, maxBoxTop));

        cropState.boxLeft = newLeft;
        cropState.boxTop = newTop;
    } else if (cropState.isPanning) {
        imgPanX += dx;
        imgPanY += dy;
        updateCanvasPosition();

        // Update start reference for smooth delta
        cropState.startX = e.clientX;
        cropState.startY = e.clientY;

        const rect = ImageSysCanvas.getBoundingClientRect();
        cropState.renderLeftOff = rect.left - wrapperRect.left;
        cropState.renderTopOff = rect.top - wrapperRect.top;
    } else if (cropState.isResizing) {
        let newW = cropState.startWidth;
        let newH = cropState.startHeight;
        let newL = cropState.startLeft;
        let newT = cropState.startTop;

        const ratio = currentRatio;

        if (cropState.resizeHandle.includes('e')) {
            newW = cropState.startWidth + dx;
        } else if (cropState.resizeHandle.includes('w')) {
            newW = cropState.startWidth - dx;
            newL = cropState.startLeft + dx;
        }

        if (newW < 20) newW = 20;

        if (ratio !== 'free') {
            newH = newW / ratio;
        } else {
            if (cropState.resizeHandle.includes('n')) {
                newH = cropState.startHeight - dy;
            } else if (cropState.resizeHandle.includes('s')) {
                newH = cropState.startHeight + dy;
            }
            if (newH < 20) newH = 20;
        }

        if (cropState.resizeHandle.includes('w')) {
            newL = cropState.startLeft + (cropState.startWidth - newW);
        }

        if (cropState.resizeHandle.includes('n')) {
            if (ratio !== 'free') {
                newT = cropState.startTop + (cropState.startHeight - newH);
            } else {
                newT = cropState.startTop + dy;
            }
        }

        if (ratio === 'free') {
            if (newL < minLeft) {
                const diff = minLeft - newL;
                newL = minLeft;
                newW -= diff;
            }
            if (newL + newW > maxLeft) {
                newW = maxLeft - newL;
            }
            if (cropState.resizeHandle.includes('n')) {
                if (newT < minTop) {
                    const diff = minTop - newT;
                    newT = minTop;
                    newH -= diff;
                }
            } else if (cropState.resizeHandle.includes('s')) {
                if (newT + newH > maxTop) {
                    newH = maxTop - newT;
                }
            }
        } else {
            if (newL < minLeft) {
                newL = minLeft;
                newW = cropState.startWidth + (cropState.startLeft - newL);
                newH = newW / ratio;
                if (cropState.resizeHandle.includes('n')) newT = cropState.startTop + (cropState.startHeight - newH);
            }
            if (newT < minTop) {
                newT = minTop;
                newH = cropState.startHeight + (cropState.startTop - newT);
                newW = newH * ratio;
                if (cropState.resizeHandle.includes('w')) newL = cropState.startLeft + (cropState.startWidth - newW);
            }
            if (newL + newW > maxLeft) {
                newW = maxLeft - newL;
                newH = newW / ratio;
                if (cropState.resizeHandle.includes('n')) newT = cropState.startTop + (cropState.startHeight - newH);
            }
            if (newT + newH > maxTop) {
                newH = maxTop - newT;
                newW = newH * ratio;
                if (cropState.resizeHandle.includes('w')) newL = cropState.startLeft + (cropState.startWidth - newW);
            }
        }

        cropState.boxWidth = newW;
        cropState.boxHeight = newH;
        cropState.boxLeft = newL;
        cropState.boxTop = newT;
    }

    cropBox.style.width = `${cropState.boxWidth}px`;
    cropBox.style.height = `${cropState.boxHeight}px`;
    cropBox.style.left = `${cropState.boxLeft}px`;
    cropBox.style.top = `${cropState.boxTop}px`;

    cropState.realX = (cropState.boxLeft - cropState.renderLeftOff) / cropState.scaleX;
    cropState.realY = (cropState.boxTop - cropState.renderTopOff) / cropState.scaleY;
    cropState.realW = cropState.boxWidth / cropState.scaleX;
    cropState.realH = cropState.boxHeight / cropState.scaleY;
}

function onMouseUp() {
    if (cropState.isDragging || cropState.isResizing || cropState.isPanning) {
        cropState.isDragging = false;
        cropState.isResizing = false;
        cropState.isPanning = false;
        imageWrapper.style.cursor = 'crosshair'; // Reset to default background cursor
        refreshProcessedImage();
    }
}

/**
 * Centralized Logic for preparing the processed image canvas.
 * Handles background filling, letterboxing/pillarboxing, and coordinate mapping.
 * @returns {HTMLCanvasElement} A canvas with the cropped and fitted image content.
 */
function prepareProcessedCanvas() {
    const sourceCanvas = ImageSysCanvas;
    const canvas = document.createElement('canvas');
    canvas.width = targetW;
    canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // 1. Fill background
    ctx.fillStyle = BgColorText ? BgColorText.value : "#FFFFFF";
    ctx.fillRect(0, 0, targetW, targetH);

    // 2. Geometry Calculation (Direct mapping from raw canvas coordinates)
    const srcX = cropState.realX, srcY = cropState.realY;
    const srcW = cropState.realW, srcH = cropState.realH;

    const imgLeft = 0, imgTop = 0;
    const imgRight = sourceCanvas.width, imgBottom = sourceCanvas.height;
    const cropLeft = srcX, cropTop = srcY;
    const cropRight = srcX + srcW, cropBottom = srcY + srcH;

    // Calculate intersection
    const intersectLeft = Math.max(imgLeft, cropLeft);
    const intersectTop = Math.max(imgTop, cropTop);
    const intersectRight = Math.min(imgRight, cropRight);
    const intersectBottom = Math.min(imgBottom, cropBottom);

    if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
        const intersectW = intersectRight - intersectLeft;
        const intersectH = intersectBottom - intersectTop;
        const offsetX = intersectLeft - cropLeft;
        const offsetY = intersectTop - cropTop;

        const srcRatio = srcW / srcH;
        const targetRatio = targetW / targetH;

        let dstW, dstH, dstX, dstY;
        if (srcRatio > targetRatio) {
            dstW = targetW;
            dstH = targetW / srcRatio;
            dstX = 0;
            dstY = (targetH - dstH) / 2;
        } else {
            dstH = targetH;
            dstW = targetH * srcRatio;
            dstY = 0;
            dstX = (targetW - dstW) / 2;
        }

        const dstOffsetX = dstX + (offsetX / srcW) * dstW;
        const dstOffsetY = dstY + (offsetY / srcH) * dstH;
        const dstIntersectW = (intersectW / srcW) * dstW;
        const dstIntersectH = (intersectH / srcH) * dstH;

        ctx.drawImage(sourceCanvas,
            intersectLeft, intersectTop, intersectW, intersectH,
            dstOffsetX, dstOffsetY, dstIntersectW, dstIntersectH
        );
    }
    return canvas;
}

function processCroppedImage() {
    const canvas = prepareProcessedCanvas();
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const palette = [[0, 0, 0], [255, 255, 255], [255, 255, 0], [255, 0, 0], null, [0, 0, 255], [0, 255, 0]];

    function findNearestColorIndex(r, g, b) {
        let minDist = Infinity, nearestIdx = 0;
        for (let i = 0; i < palette.length; i++) {
            if (palette[i] === null) continue;
            const dist = (r - palette[i][0]) ** 2 + (g - palette[i][1]) ** 2 + (b - palette[i][2]) ** 2;
            if (dist < minDist) { minDist = dist; nearestIdx = i; }
        }
        return nearestIdx;
    }

    const idxArr = new Uint8Array(canvas.width * canvas.height);
    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
            const idx = findNearestColorIndex(oldR, oldG, oldB);
            const [newR, newG, newB] = palette[idx];
            data[i] = newR; data[i + 1] = newG; data[i + 2] = newB;
            idxArr[y * canvas.width + x] = idx;
            const errR = oldR - newR, errG = oldG - newG, errB = oldB - newB;

            if (x + 1 < canvas.width) {
                let j = i + 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 7 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 7 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 7 / 16));
            }
            if (x > 0 && y + 1 < canvas.height) {
                let j = i + (canvas.width - 1) * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 3 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 3 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 3 / 16));
            }
            if (y + 1 < canvas.height) {
                let j = i + canvas.width * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 5 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 5 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 5 / 16));
            }
            if (x + 1 < canvas.width && y + 1 < canvas.height) {
                let j = i + (canvas.width + 1) * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 1 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 1 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 1 / 16));
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
    processedCanvas = canvas; // Cache the canvas
    processedBase64 = canvas.toDataURL();
    window._lastImageIndexArray = idxArr;
    updatePreview();
}

function updatePreview() {
    if (!processedBase64) return;
    const processedImg = document.getElementById('Image_Processed');
    processedImg.src = processedBase64;
    processedImg.classList.add('has-image');
    // Ensure ink-sim-active class is synced with the checkbox on initial render/update
    const inkSimToggle = document.getElementById("Ink_Sim_Toggle");
    if (inkSimToggle && inkSimToggle.checked) {
        processedImg.classList.add('ink-sim-active');
    } else {
        processedImg.classList.remove('ink-sim-active');
    }
}

// Optimized E6 Dithering Algorithm
function processCroppedImageE6() {
    const canvas = prepareProcessedCanvas();
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // --- Pre-processing with Dynamic Parameters ---
    const gamma = parseFloat(document.getElementById("Slider_Gamma").value);
    const contrastStrength = parseFloat(document.getElementById("Slider_Contrast").value);
    const saturation = parseFloat(document.getElementById("Slider_Saturation").value);
    const ditherIntensity = parseFloat(document.getElementById("Slider_Dither").value);
    const errorThreshold = parseFloat(document.getElementById("Slider_Threshold").value);

    const gammaMap = new Uint8Array(256);
    for (let i = 0; i < 256; i++) {
        let v = i / 255;
        v = Math.pow(v, gamma);
        const x = v * 2 - 1;
        v = v + contrastStrength * (x - x * x * x) / 2;
        gammaMap[i] = Math.max(0, Math.min(1, v)) * 255;
    }

    const jitterAmount = 4;
    for (let i = 0; i < data.length; i += 4) {
        const r0 = data[i], g0 = data[i + 1], b0 = data[i + 2];
        const gray = 0.299 * r0 + 0.587 * g0 + 0.114 * b0;
        let r1 = Math.max(0, Math.min(255, gray + (r0 - gray) * saturation));
        let g1 = Math.max(0, Math.min(255, gray + (g0 - gray) * saturation));
        let b1 = Math.max(0, Math.min(255, gray + (b0 - gray) * saturation));
        r1 = gammaMap[Math.round(r1)]; g1 = gammaMap[Math.round(g1)]; b1 = gammaMap[Math.round(b1)];
        const noise = (Math.random() - 0.5) * jitterAmount;
        data[i] = Math.max(0, Math.min(255, r1 + noise));
        data[i + 1] = Math.max(0, Math.min(255, g1 + noise));
        data[i + 2] = Math.max(0, Math.min(255, b1 + noise));
    }

    const palette = [[0, 0, 0], [255, 255, 255], [255, 255, 0], [255, 0, 0], null, [0, 0, 255], [0, 255, 0]];
    const idxArr = new Uint8Array(canvas.width * canvas.height);

    for (let y = 0; y < canvas.height; y++) {
        const isForward = (y % 2 === 0);
        if (isForward) {
            for (let x = 0; x < canvas.width; x++) applyDither(x, y, 1);
        } else {
            for (let x = canvas.width - 1; x >= 0; x--) applyDither(x, y, -1);
        }
    }

    function applyDither(x, y, dir) {
        const i = (y * canvas.width + x) * 4;
        const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];

        let minDist = Infinity, idx = 0;
        for (let p = 0; p < palette.length; p++) {
            if (palette[p] === null) continue;
            const dist = 2 * (oldR - palette[p][0]) ** 2 + 4 * (oldG - palette[p][1]) ** 2 + 3 * (oldB - palette[p][2]) ** 2;
            if (dist < minDist) { minDist = dist; idx = p; }
        }

        const [newR, newG, newB] = palette[idx];
        data[i] = newR; data[i + 1] = newG; data[i + 2] = newB;
        idxArr[y * canvas.width + x] = idx;

        const errR = (oldR - newR), errG = (oldG - newG), errB = (oldB - newB);
        if (Math.abs(errR) < errorThreshold && Math.abs(errG) < errorThreshold && Math.abs(errB) < errorThreshold) return;

        const eR = errR * ditherIntensity / 8, eG = errG * ditherIntensity / 8, eB = errB * ditherIntensity / 8;

        const spread = (dx, dy) => {
            const nx = x + dx * dir, ny = y + dy;
            if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                const j = (ny * canvas.width + nx) * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + eR));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + eG));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + eB));
            }
        };
        spread(1, 0); spread(2, 0); spread(-1, 1); spread(0, 1); spread(1, 1); spread(0, 2);
    }

    ctx.putImageData(imageData, 0, 0);
    processedCanvas = canvas; // Cache the canvas
    processedBase64 = canvas.toDataURL();
    window._lastImageIndexArray = idxArr;
    updatePreview();
}

function InPutButton_Even() {
    FileInput.click();
}

async function FileInput_Even(e) {
    fileFlag = 0;
    let file = e.target.files[0];
    if (!file) {
        alert("No file selected");
        return;
    }

    const isHEIC = file.name.toLowerCase().endsWith(".heic") || file.name.toLowerCase().endsWith(".heif") || file.type === "image/heic" || file.type === "image/heif";

    if (isHEIC) {
        if (typeof heic2any === "undefined") {
            alert("HEIC conversion library (heic2any) not loaded. Please ensure you are online or the library is available.");
            return;
        }
        try {
            InPutButton.disabled = true;
            const originalBtnHtml = InPutButton.innerHTML;
            InPutButton.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Converting HEIC...`;

            const convertedBlob = await heic2any({
                blob: file,
                toType: "image/jpeg",
                quality: 1.0
            });
            file = new File([Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob], file.name.replace(/\.[^/.]+$/, "") + ".jpg", { type: "image/jpeg" });

            InPutButton.disabled = false;
            InPutButton.innerHTML = originalBtnHtml;
        } catch (err) {
            console.error("HEIC conversion failed:", err);
            alert("Failed to convert HEIC image: " + err.message);
            InPutButton.disabled = false;
            // Reset button html will be handled below or on error
            return;
        }
    } else if (!file.type.startsWith("image/")) {
        alert("Please select an image file");
        return;
    }

    const url = URL.createObjectURL(file);
    originalImage.onerror = function () {
        URL.revokeObjectURL(url);
        alert("Failed to load image. The file may be corrupt.");
    };
    originalImage.onload = function () {
        URL.revokeObjectURL(url);

        const imgRatio = originalImage.naturalWidth / originalImage.naturalHeight;
        if (imgRatio > 1 && screenOrientation === 'portrait') applyScreenOrientation('landscape');
        else if (imgRatio < 1 && screenOrientation === 'landscape') applyScreenOrientation('portrait');

        sourceRotateAngle = 0; isMirrored = false;
        imageScale = 1.0; baseFitScale = 1.0;
        imgPanX = 0; imgPanY = 0;
        fileFlag = 1;

        if (SourcePlaceholder) SourcePlaceholder.style.display = 'none';
        if (ImageSysCanvas) ImageSysCanvas.style.display = 'block';

        renderSourceCanvas().then(() => initCropForImage());
    }
    originalImage.src = url;
    e.target.value = '';
}

function SendButton_Even() {
    if (!fileFlag || !processedCanvas) {
        alert("Please select and process a picture first.");
        return;
    }

    const width = processedCanvas.width;
    const height = processedCanvas.height;
    const ctx = processedCanvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, width, height);
    const modeByte = (currentMode === "STA") ? 1 : 0;

    function createBMPUint8Array(imageData, width, height) {
        const bytesPerPixel = 3;
        const rowSize = Math.ceil((bytesPerPixel * width) / 4) * 4;
        const pixelDataSize = rowSize * height;
        const bmpFileHeaderSize = 14;
        const bmpInfoHeaderSize = 40;
        const totalBmpSize = bmpFileHeaderSize + bmpInfoHeaderSize + pixelDataSize;

        const bmpData = new Uint8Array(totalBmpSize);
        const dataView = new DataView(bmpData.buffer);

        dataView.setUint8(0, 0x42); dataView.setUint8(1, 0x4D);
        dataView.setUint32(2, totalBmpSize, true);
        dataView.setUint16(6, 0, true); dataView.setUint16(8, 0, true);
        dataView.setUint32(10, 54, true);

        dataView.setUint32(14, 40, true);
        dataView.setUint32(18, width, true); dataView.setUint32(22, height, true);
        dataView.setUint16(26, 1, true); dataView.setUint16(28, 24, true);
        dataView.setUint32(30, 0, true); dataView.setUint32(34, pixelDataSize, true);
        dataView.setUint32(38, 72, true); dataView.setUint32(42, 72, true);
        dataView.setUint32(46, 0, true); dataView.setUint32(50, 0, true);

        const rgba = imageData.data;
        let pixelOffset = 54;
        for (let y = height - 1; y >= 0; y--) {
            let rowOffset = 0;
            for (let x = 0; x < width; x++) {
                const i = (y * width + x) * 4;
                bmpData[pixelOffset + rowOffset] = rgba[i + 2];     // B
                bmpData[pixelOffset + rowOffset + 1] = rgba[i + 1]; // G
                bmpData[pixelOffset + rowOffset + 2] = rgba[i];     // R
                rowOffset += 3;
            }
            while (rowOffset % 4 !== 0) { bmpData[pixelOffset + rowOffset] = 0; rowOffset++; }
            pixelOffset += rowSize;
        }
        return bmpData;
    }

    const pureBmpData = createBMPUint8Array(imageData, width, height);
    const finalData = new Uint8Array(1 + pureBmpData.length);
    finalData[0] = modeByte;
    finalData.set(pureBmpData, 1);

    SendButton.disabled = true;
    const originalBtnHtml = SendButton.innerHTML;
    SendButton.innerHTML = `<span class="spinner-border spinner-border-sm"></span> Sending...`;

    fetch("/dataUP", { method: "POST", body: new Blob([finalData]) })
        .then(res => {
            if (!res.ok) throw new Error(`Upload failed! ${res.status}`);
            alert('Upload successful!');
        })
        .catch(err => alert("Upload failed! : " + err.message))
        .finally(() => { SendButton.disabled = false; SendButton.innerHTML = originalBtnHtml; });
}

function bindModeButtonEvents() {
    modeButtons.forEach(button => {
        button.addEventListener('click', function (event) {
            event.preventDefault();
            const targetMode = this.dataset.mode;
            updateModeByValue(targetMode);
        });
    });
}

document.addEventListener('DOMContentLoaded', function () {
    modeButtons = document.querySelectorAll('a[data-mode]');
    tips = document.querySelectorAll('#tips > div');

    bindModeButtonEvents();

    Even_init();

    fetch('/NetWorkStatus')
        .then(response => {
            if (!response.ok) {
                throw new Error(`Request failed, status code:${response.status}`);
            }
            return response.text();
        })
        .then(data => {
            let serverMode = 'AP';
            const serverCode = parseInt(data);
            if (!isNaN(serverCode)) {
                serverMode = serverCode === 1 ? 'STA' : 'AP';
            }
            updateModeByValue(serverMode);
        })
        .catch(error => {
            console.error('Failed to obtain network status. Using default AP mode:', error);
            initializeMode();
        });
});