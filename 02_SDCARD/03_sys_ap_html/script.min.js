let ImageSysCanvas, SourcePlaceholder, InPutButton, SendButton, FileInput, BtnBgBlack, BtnBgWhite, BgColorText;
let SrcRotateLBtn, SrcRotateRBtn, SrcMirrorBtn, ZoomInBtn, ZoomOutBtn, RatioDropdownBtn, RatioMenu;
let modeButtons, tips;
let currentMode = 'AP';
let processedBase64 = "";
let fileFlag = 0;
let currentRatio = 5 / 3; // Default 5:3, can be 'free'

// Source manipulation state
let originalImage = new Image();
let sourceRotateAngle = 0; // 0, 90, 180, 270
let isMirrored = false;
let imageScale = 1.0; // Zoom scale, 1.0 = 100%
let baseFitScale = 1.0; // Auto-calculated fit scale
const MIN_SCALE = 0.1; // Minimum 10%
const MAX_SCALE = 5.0; // Maximum 500%
const ZOOM_FACTOR = 1.1; // 10% zoom per step (multiplicative)

function updateModeByValue(targetMode) {
    const validModes = ['AP', 'STA'];
    if (!validModes.includes(targetMode)) {
        console.warn('Invalid mode value. Using default AP mode.');
        targetMode = 'AP';
    }

    const activeButton = document.querySelector(`a[data-mode="${targetMode}"]`);
    if (activeButton) {
        modeButtons.forEach(btn => btn.classList.remove('active'));
        activeButton.classList.add('active');
        currentMode = targetMode;
        updateTips();
    }
}

function initializeMode() {
    updateModeByValue('AP');
}

function updateTips() {
    tips.forEach(tip => tip.classList.remove('d-none'));
    if (currentMode === "AP") {
        document.getElementById('tips-STA')?.classList.add('d-none');
    } else {
        document.getElementById('tips-AP')?.classList.add('d-none');
    }
}

function Even_init() {
    InPutButton = document.getElementById("Input_Button");
    SendButton = document.getElementById("Send_Button");
    FileInput = document.getElementById("File_Input");
    ImageSysCanvas = document.getElementById("Image_Input_Canvas"); // Now a Canvas
    SourcePlaceholder = document.getElementById("Image_Placeholder");

    // New Bg Color Controls
    BtnBgBlack = document.getElementById("Btn_Bg_Black");
    BtnBgWhite = document.getElementById("Btn_Bg_White");
    BgColorText = document.getElementById("Bg_Color_Text");

    cropBox = document.getElementById("Crop_Box");
    imageWrapper = document.getElementById("Image_Wrapper");

    // New Source Control Buttons
    SrcRotateLBtn = document.getElementById("Src_Rotate_L");
    SrcRotateRBtn = document.getElementById("Src_Rotate_R");
    SrcMirrorBtn = document.getElementById("Src_Mirror");
    ZoomInBtn = document.getElementById("Zoom_In");
    ZoomOutBtn = document.getElementById("Zoom_Out");
    RatioDropdownBtn = document.getElementById("Ratio_Dropdown");
    RatioMenu = document.querySelector(".dropdown-menu");

    // Add handles
    const handles = ['nw', 'ne', 'sw', 'se'];
    handles.forEach(pos => {
        let h = document.createElement('div');
        h.className = `crop-handle handle-${pos}`;
        h.dataset.handle = pos;
        cropBox.appendChild(h);
    });

    updateRatioButtonText();

    InPutButton.addEventListener("click", InPutButton_Even);
    FileInput.addEventListener("change", FileInput_Even);
    SendButton.addEventListener("click", SendButton_Even);

    // Bg Color Events
    if (BtnBgBlack) BtnBgBlack.addEventListener("click", () => setBgColor("#000000"));
    if (BtnBgWhite) BtnBgWhite.addEventListener("click", () => setBgColor("#FFFFFF"));
    if (BgColorText) BgColorText.addEventListener("input", processCroppedImage);

    // Source manipulation events
    if (SrcRotateLBtn) SrcRotateLBtn.addEventListener("click", () => rotateSource(-90));
    if (SrcRotateRBtn) SrcRotateRBtn.addEventListener("click", () => rotateSource(90));
    if (SrcMirrorBtn) SrcMirrorBtn.addEventListener("click", toggleMirror);
    if (ZoomInBtn) ZoomInBtn.addEventListener("click", zoomIn);
    if (ZoomOutBtn) ZoomOutBtn.addEventListener("click", zoomOut);

    // Ratio Dropdown events
    if (RatioMenu) {
        RatioMenu.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const r = e.target.dataset.ratio;
                setCropRatio(r);
            });
        });
    }

    // Crop events
    cropBox.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);

    // Touch support
    cropBox.addEventListener('touchstart', (e) => onMouseDown(e.touches[0], e));
    document.addEventListener('touchmove', (e) => onMouseMove(e.touches[0], e));
    document.addEventListener('touchend', onMouseUp);

    window.addEventListener('resize', () => {
        if (fileFlag) initCropForImage();
    });
}

function setBgColor(color) {
    if (BgColorText) BgColorText.value = color;
    processCroppedImage();
}

function updateRatioButtonText() {
    if (!RatioDropdownBtn) return;
    let text = "Ratio: ";
    if (currentRatio === 'free') {
        text += "Free";
    } else if (Math.abs(currentRatio - 5 / 3) < 0.01) {
        text += "5:3";
    } else if (Math.abs(currentRatio - 3 / 5) < 0.01) {
        text += "3:5";
    } else if (Math.abs(currentRatio - 1) < 0.01) {
        text += "1:1";
    } else {
        text += "Custom";
    }
    RatioDropdownBtn.textContent = text;
}

function setCropRatio(r) {
    if (!fileFlag) return;

    if (r === 'free') {
        currentRatio = 'free';
    } else {
        currentRatio = parseFloat(r);
    }
    updateRatioButtonText();
    initCropForImage(); // Reset crop box to new ratio
}

function rotateSource(deg) {
    if (!fileFlag) return;
    sourceRotateAngle = (sourceRotateAngle + deg + 360) % 360;
    // Reset scale to trigger auto-fit for new orientation
    baseFitScale = 1.0;
    imageScale = 1.0;
    renderSourceCanvas().then(() => initCropForImage());
}

function toggleMirror() {
    if (!fileFlag) return;
    isMirrored = !isMirrored;
    renderSourceCanvas().then(() => initCropForImage());
}

function zoomIn() {
    if (!fileFlag) return;
    imageScale = Math.min(imageScale * ZOOM_FACTOR, MAX_SCALE);
    renderSourceCanvas().then(() => initCropForImage());
}

function zoomOut() {
    if (!fileFlag) return;
    imageScale = Math.max(imageScale / ZOOM_FACTOR, MIN_SCALE);
    renderSourceCanvas().then(() => initCropForImage());
}

function renderSourceCanvas() {
    return new Promise((resolve) => {
        if (!originalImage.src) {
            resolve();
            return;
        }

        const canvas = ImageSysCanvas;
        const ctx = canvas.getContext('2d');

        // Determine dims based on rotation
        let targetW = originalImage.naturalWidth;
        let targetH = originalImage.naturalHeight;

        if (sourceRotateAngle % 180 !== 0) {
            targetW = originalImage.naturalHeight;
            targetH = originalImage.naturalWidth;
        }

        // Calculate fit scale if this is initial load (imageScale === 1.0 and baseFitScale === 1.0)
        if (imageScale === 1.0 && baseFitScale === 1.0) {
            const wrapperRect = imageWrapper.getBoundingClientRect();
            const fitScaleW = wrapperRect.width / targetW;
            const fitScaleH = wrapperRect.height / targetH;
            baseFitScale = Math.min(fitScaleW, fitScaleH, 1.0); // Don't upscale, max 1.0
            imageScale = baseFitScale;
        }

        // Apply zoom scale
        canvas.width = targetW * imageScale;
        canvas.height = targetH * imageScale;

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        if (isMirrored) {
            ctx.scale(-1, 1);
        }
        ctx.rotate(sourceRotateAngle * Math.PI / 180);

        // Scale the image to match the canvas size
        const scaledW = originalImage.naturalWidth * imageScale;
        const scaledH = originalImage.naturalHeight * imageScale;
        ctx.drawImage(originalImage, -scaledW / 2, -scaledH / 2, scaledW, scaledH);
        ctx.restore();

        resolve();
    });
}

function initCropForImage() {
    // img is now ImageSysCanvas
    const canvas = ImageSysCanvas;
    if (canvas.width === 0 || canvas.height === 0) return;

    cropState.imgNaturalWidth = canvas.width;
    cropState.imgNaturalHeight = canvas.height;

    // Get displayed dimensions directly from the element
    const rect = canvas.getBoundingClientRect();
    const wrapperRect = imageWrapper.getBoundingClientRect();

    // rect gives the actual painted area + offsets
    const renderW = rect.width;
    const renderH = rect.height;

    // Calculate offsets relative to the wrapper
    const renderLeft = rect.left - wrapperRect.left;
    const renderTop = rect.top - wrapperRect.top;

    cropState.scaleX = renderW / canvas.width;
    cropState.scaleY = renderH / canvas.height;
    cropState.renderLeftOff = renderLeft;
    cropState.renderTopOff = renderTop;

    // Initialize crop box size - maximize to fill image while maintaining ratio
    let targetRatio = currentRatio === 'free' ? 5 / 3 : currentRatio;
    const imgRatio = canvas.width / canvas.height;

    // Choose the dimension that allows maximum crop box size
    if (imgRatio > targetRatio) {
        // Image is wider than target ratio, constrain by height
        cropState.realH = canvas.height;
        cropState.realW = Math.ceil(canvas.height * targetRatio);
    } else {
        // Image is taller than target ratio, constrain by width
        cropState.realW = canvas.width;
        cropState.realH = Math.ceil(canvas.width / targetRatio);
    }

    // Center the crop box (use floor to avoid overflow)
    cropState.realX = Math.floor((canvas.width - cropState.realW) / 2);
    cropState.realY = Math.floor((canvas.height - cropState.realH) / 2);

    cropBox.style.display = 'block';

    updateCropUI();
    processCroppedImage();
}

function updateCropUI() {
    cropState.boxWidth = cropState.realW * cropState.scaleX;
    cropState.boxHeight = cropState.realH * cropState.scaleY;
    cropState.boxLeft = cropState.realX * cropState.scaleX + cropState.renderLeftOff;
    cropState.boxTop = cropState.realY * cropState.scaleY + cropState.renderTopOff;

    cropBox.style.width = `${cropState.boxWidth}px`;
    cropBox.style.height = `${cropState.boxHeight}px`;
    cropBox.style.left = `${cropState.boxLeft}px`;
    cropBox.style.top = `${cropState.boxTop}px`;
}

function onMouseDown(e, originalEvent) {
    if (!fileFlag) return;
    if (originalEvent) originalEvent.preventDefault();
    else e.preventDefault();

    const target = originalEvent ? originalEvent.target : e.target;

    if (target.classList.contains('crop-handle')) {
        cropState.isResizing = true;
        cropState.resizeHandle = target.dataset.handle;
    } else {
        cropState.isDragging = true;
    }

    cropState.startX = e.clientX;
    cropState.startY = e.clientY;
    cropState.startLeft = cropState.boxLeft;
    cropState.startTop = cropState.boxTop;
    cropState.startWidth = cropState.boxWidth;
    cropState.startHeight = cropState.boxHeight;
}

function onMouseMove(e, originalEvent) {
    if (!cropState.isDragging && !cropState.isResizing) return;
    if (originalEvent) originalEvent.preventDefault();
    else e.preventDefault();

    const dx = e.clientX - cropState.startX;
    const dy = e.clientY - cropState.startY;

    // Allow crop box to move within entire container, not just image bounds
    const wrapperRect = imageWrapper.getBoundingClientRect();
    const minLeft = 0;
    const maxLeft = wrapperRect.width;
    const minTop = 0;
    const maxTop = wrapperRect.height;

    if (cropState.isDragging) {
        let newLeft = cropState.startLeft + dx;
        let newTop = cropState.startTop + dy;

        const maxBoxLeft = maxLeft - cropState.boxWidth;
        const maxBoxTop = maxTop - cropState.boxHeight;

        newLeft = Math.max(minLeft, Math.min(newLeft, maxBoxLeft));
        newTop = Math.max(minTop, Math.min(newTop, maxBoxTop));

        cropState.boxLeft = newLeft;
        cropState.boxTop = newTop;
    } else if (cropState.isResizing) {
        let newW = cropState.startWidth;
        let newH = cropState.startHeight;
        let newL = cropState.startLeft;
        let newT = cropState.startTop;

        const ratio = currentRatio;

        if (cropState.resizeHandle.includes('e')) {
            newW = cropState.startWidth + dx;
        } else if (cropState.resizeHandle.includes('w')) {
            newW = cropState.startWidth - dx;
            newL = cropState.startLeft + dx;
        }

        if (newW < 20) newW = 20;

        if (ratio !== 'free') {
            newH = newW / ratio;
        } else {
            if (cropState.resizeHandle.includes('n')) {
                newH = cropState.startHeight - dy;
            } else if (cropState.resizeHandle.includes('s')) {
                newH = cropState.startHeight + dy;
            }
            if (newH < 20) newH = 20;
        }


        if (cropState.resizeHandle.includes('w')) {
            newL = cropState.startLeft + (cropState.startWidth - newW);
        }

        if (cropState.resizeHandle.includes('n')) {
            if (ratio !== 'free') {
                newT = cropState.startTop + (cropState.startHeight - newH);
            } else {
                newT = cropState.startTop + dy;
            }
        }

        if (ratio === 'free') {
            if (cropState.resizeHandle.includes('w')) {
            } else if (cropState.resizeHandle.includes('e')) {
            }

            if (newL < minLeft) {
                const diff = minLeft - newL;
                newL = minLeft;
                newW -= diff;
            }
            if (newL + newW > maxLeft) {
                newW = maxLeft - newL;
            }

            if (cropState.resizeHandle.includes('n')) {
                if (newT < minTop) {
                    const diff = minTop - newT;
                    newT = minTop;
                    newH -= diff;
                }
            } else if (cropState.resizeHandle.includes('s')) {
                if (newT + newH > maxTop) {
                    newH = maxTop - newT;
                }
            }

        } else {
            if (newL < minLeft) {
                newL = minLeft;
                newW = cropState.startWidth + (cropState.startLeft - newL);
                newH = newW / ratio;
                if (cropState.resizeHandle.includes('n')) newT = cropState.startTop + (cropState.startHeight - newH);
            }

            if (newT < minTop) {
                newT = minTop;
                newH = cropState.startHeight + (cropState.startTop - newT);
                newW = newH * ratio;
                if (cropState.resizeHandle.includes('w')) newL = cropState.startLeft + (cropState.startWidth - newW);
            }

            if (newL + newW > maxLeft) {
                newW = maxLeft - newL;
                newH = newW / ratio;
                if (cropState.resizeHandle.includes('n')) newT = cropState.startTop + (cropState.startHeight - newH);
            }

            if (newT + newH > maxTop) {
                newH = maxTop - newT;
                newW = newH * ratio;
                if (cropState.resizeHandle.includes('w')) newL = cropState.startLeft + (cropState.startWidth - newW);
            }
        }

        cropState.boxWidth = newW;
        cropState.boxHeight = newH;
        cropState.boxLeft = newL;
        cropState.boxTop = newT;
    }

    cropBox.style.width = `${cropState.boxWidth}px`;
    cropBox.style.height = `${cropState.boxHeight}px`;
    cropBox.style.left = `${cropState.boxLeft}px`;
    cropBox.style.top = `${cropState.boxTop}px`;

    cropState.realX = (cropState.boxLeft - cropState.renderLeftOff) / cropState.scaleX;
    cropState.realY = (cropState.boxTop - cropState.renderTopOff) / cropState.scaleY;
    cropState.realW = cropState.boxWidth / cropState.scaleX;
    cropState.realH = cropState.boxHeight / cropState.scaleY;
}

function onMouseUp() {
    if (cropState.isDragging || cropState.isResizing) {
        cropState.isDragging = false;
        cropState.isResizing = false;
        processCroppedImage();
    }
}

let cropState = {
    isDragging: false,
    isResizing: false,
    resizeHandle: null,
    startX: 0,
    startY: 0,
    startLeft: 0,
    startTop: 0,
    startWidth: 0,
    startHeight: 0,
    imgNaturalWidth: 0,
    imgNaturalHeight: 0,
    scaleX: 1,
    scaleY: 1,
    boxLeft: 0,
    boxTop: 0,
    boxWidth: 0,
    boxHeight: 0,
    realX: 0,
    realY: 0,
    realW: 0,
    realH: 0,
    renderLeftOff: 0,
    renderTopOff: 0
};

function processCroppedImage() {
    const sourceCanvas = ImageSysCanvas;
    const targetW = 800;
    const targetH = 480;

    const canvas = document.createElement('canvas');
    canvas.width = targetW;
    canvas.height = targetH;
    const ctx = canvas.getContext('2d');

    // Fill background
    ctx.fillStyle = BgColorText ? BgColorText.value : "#FFFFFF";
    ctx.fillRect(0, 0, targetW, targetH);

    // Calculate crop box position relative to canvas
    // cropState.realX/Y are in canvas coordinate system
    const srcX = cropState.realX;
    const srcY = cropState.realY;
    const srcW = cropState.realW;
    const srcH = cropState.realH;

    // Calculate intersection between crop box and actual image
    // Image bounds in canvas coordinates: (0, 0) to (sourceCanvas.width, sourceCanvas.height)
    const imgLeft = 0;
    const imgTop = 0;
    const imgRight = sourceCanvas.width;
    const imgBottom = sourceCanvas.height;

    const cropLeft = srcX;
    const cropTop = srcY;
    const cropRight = srcX + srcW;
    const cropBottom = srcY + srcH;

    // Calculate intersection
    const intersectLeft = Math.max(imgLeft, cropLeft);
    const intersectTop = Math.max(imgTop, cropTop);
    const intersectRight = Math.min(imgRight, cropRight);
    const intersectBottom = Math.min(imgBottom, cropBottom);

    // Check if there's any intersection
    if (intersectRight > intersectLeft && intersectBottom > intersectTop) {
        // There is an intersection, draw it
        const intersectW = intersectRight - intersectLeft;
        const intersectH = intersectBottom - intersectTop;

        // Position within the crop box where the image starts
        const offsetX = intersectLeft - cropLeft;
        const offsetY = intersectTop - cropTop;

        // Calculate destination drawing based on aspect fit
        const srcRatio = srcW / srcH;
        const targetRatio = targetW / targetH;

        let dstW, dstH, dstX, dstY;

        if (srcRatio > targetRatio) {
            // Source is wider than target (letterbox)
            dstW = targetW;
            dstH = targetW / srcRatio;
            dstX = 0;
            dstY = (targetH - dstH) / 2;
        } else {
            // Source is taller than target (pillarbox)
            dstH = targetH;
            dstW = targetH * srcRatio;
            dstY = 0;
            dstX = (targetW - dstW) / 2;
        }

        // Calculate the portion of destination to draw
        const dstOffsetX = dstX + (offsetX / srcW) * dstW;
        const dstOffsetY = dstY + (offsetY / srcH) * dstH;
        const dstIntersectW = (intersectW / srcW) * dstW;
        const dstIntersectH = (intersectH / srcH) * dstH;

        // Draw only the intersection part
        ctx.drawImage(sourceCanvas,
            intersectLeft, intersectTop, intersectW, intersectH,
            dstOffsetX, dstOffsetY, dstIntersectW, dstIntersectH
        );
    }
    // If no intersection, the canvas remains filled with background color

    // Dithering Logic
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const palette = [
        [0, 0, 0],
        [255, 255, 255],
        [255, 255, 0],
        [255, 0, 0],
        null,
        [0, 0, 255],
        [0, 255, 0]
    ];

    function findNearestColorIndex(r, g, b) {
        let minDist = Infinity, nearestIdx = 0;
        for (let i = 0; i < palette.length; i++) {
            if (palette[i] === null) continue;
            const pr = palette[i][0], pg = palette[i][1], pb = palette[i][2];
            const dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2;
            if (dist < minDist) {
                minDist = dist;
                nearestIdx = i;
            }
        }
        return nearestIdx;
    }
    const idxArr = new Uint8Array(canvas.width * canvas.height);
    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
            const i = (y * canvas.width + x) * 4;
            const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
            const idx = findNearestColorIndex(oldR, oldG, oldB);
            const [newR, newG, newB] = palette[idx];
            data[i] = newR;
            data[i + 1] = newG;
            data[i + 2] = newB;
            idxArr[y * canvas.width + x] = idx;
            const errR = oldR - newR;
            const errG = oldG - newG;
            const errB = oldB - newB;
            if (x + 1 < canvas.width) {
                let j = i + 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 7 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 7 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 7 / 16));
            }
            if (x > 0 && y + 1 < canvas.height) {
                let j = i + (canvas.width - 1) * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 3 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 3 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 3 / 16));
            }
            if (y + 1 < canvas.height) {
                let j = i + canvas.width * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 5 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 5 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 5 / 16));
            }
            if (x + 1 < canvas.width && y + 1 < canvas.height) {
                let j = i + (canvas.width + 1) * 4;
                data[j] = Math.max(0, Math.min(255, data[j] + errR * 1 / 16));
                data[j + 1] = Math.max(0, Math.min(255, data[j + 1] + errG * 1 / 16));
                data[j + 2] = Math.max(0, Math.min(255, data[j + 2] + errB * 1 / 16));
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
    processedBase64 = canvas.toDataURL();
    window._lastImageIndexArray = idxArr;

    // Update preview (Directly, since no target rotation anymore)
    updatePreview();
}

function updatePreview() {
    if (!processedBase64) return;
    const processedImg = document.getElementById('Image_Processed');
    processedImg.src = processedBase64;

    // Sync container background with selected background color
    const container = processedImg.parentElement;
    if (container && BgColorText) {
        container.style.backgroundColor = BgColorText.value;
    }
}

function InPutButton_Even() {
    FileInput.click();
}

function FileInput_Even(e) {
    fileFlag = 0;
    const file = e.target.files[0];
    if (!file) {
        alert("No file selected");
        return;
    }
    if (!file.type.startsWith("image/")) {
        alert("Please select an image file");
        return;
    }

    const url = URL.createObjectURL(file);
    originalImage.onload = function () {
        URL.revokeObjectURL(url);
        sourceRotateAngle = 0;
        isMirrored = false;
        imageScale = 1.0; // Reset zoom
        baseFitScale = 1.0; // Reset fit scale
        fileFlag = 1;

        // Toggle visibility
        if (SourcePlaceholder) SourcePlaceholder.style.display = 'none';
        if (ImageSysCanvas) ImageSysCanvas.style.display = 'block';

        renderSourceCanvas().then(() => initCropForImage());
    }
    originalImage.src = url;

    e.target.value = '';
}

function SendButton_Even() {
    let modeByte = 0;
    if (!fileFlag) {
        alert("Please select the picture file");
        return;
    }
    if (!processedBase64) return;

    if (currentMode === "STA") {
        modeByte = 1;
    } else {
        modeByte = 0;
    }

    // Since processedBase64 is strictly 800x480 (landscape), we directly send it.
    // If the device expects 480x800 for some reason (rotation was there?), we might need check.
    // The previous code implied rotation support at the end. 
    // User requested REMOVING target rotation feature.
    // So we assume the device just takes the 800x480 bitmap.
    // Wait, if originally it supported rotation, maybe device mounts screen vertically?
    // But user explicitly asked to "Cancel target image rotation function".
    // So we send as is.

    const img = new window.Image();
    img.onload = function () {
        const width = img.naturalWidth;
        const height = img.naturalHeight;

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, width, height);

        function createBMPUint8Array(imageData, width, height) {
            const bytesPerPixel = 3;
            const rowSize = Math.ceil((bytesPerPixel * width) / 4) * 4;
            const pixelDataSize = rowSize * height;
            const bmpFileHeaderSize = 14;
            const bmpInfoHeaderSize = 40;
            const totalBmpSize = bmpFileHeaderSize + bmpInfoHeaderSize + pixelDataSize;

            const bmpData = new Uint8Array(totalBmpSize);
            const dataView = new DataView(bmpData.buffer);

            dataView.setUint8(0, 0x42);
            dataView.setUint8(1, 0x4D);
            dataView.setUint32(2, totalBmpSize, true);
            dataView.setUint16(6, 0, true);
            dataView.setUint16(8, 0, true);
            dataView.setUint32(10, bmpFileHeaderSize + bmpInfoHeaderSize, true);

            dataView.setUint32(14, bmpInfoHeaderSize, true);
            dataView.setUint32(18, width, true);
            dataView.setUint32(22, height, true);
            dataView.setUint16(26, 1, true);
            dataView.setUint16(28, bytesPerPixel * 8, true);
            dataView.setUint32(30, 0, true);
            dataView.setUint32(34, pixelDataSize, true);
            dataView.setUint32(38, 72, true);
            dataView.setUint32(42, 72, true);
            dataView.setUint32(46, 0, true);
            dataView.setUint32(50, 0, true);

            let pixelOffset = bmpFileHeaderSize + bmpInfoHeaderSize;
            const rgba = imageData.data;

            for (let y = height - 1; y >= 0; y--) {
                let rowOffset = 0;
                for (let x = 0; x < width; x++) {
                    const rgbaIndex = (y * width + x) * 4;
                    const blue = rgba[rgbaIndex + 2];
                    const green = rgba[rgbaIndex + 1];
                    const red = rgba[rgbaIndex];

                    bmpData[pixelOffset + rowOffset] = blue;
                    bmpData[pixelOffset + rowOffset + 1] = green;
                    bmpData[pixelOffset + rowOffset + 2] = red;

                    rowOffset += bytesPerPixel;
                }
                while (rowOffset % 4 !== 0) {
                    bmpData[pixelOffset + rowOffset] = 0;
                    rowOffset++;
                }
                pixelOffset += rowSize;
            }

            return bmpData;
        }

        const pureBmpData = createBMPUint8Array(imageData, width, height);

        const totalDataSize = 1 + pureBmpData.length;
        const finalData = new Uint8Array(totalDataSize);
        finalData[0] = modeByte & 0xFF;
        finalData.set(pureBmpData, 1);

        const finalBlob = new Blob([finalData], { type: 'application/octet-stream' });

        fetch("/dataUP", {
            method: "POST",
            headers: {
                "Content-Type": "application/octet-stream"
            },
            body: finalBlob
        })
            .then(res => {
                if (res.ok && res.status === 200) {
                    return res.text().then(msg => {
                        alert('Upload successful!');
                    });
                } else {
                    return res.text().then(errorMsg => {
                        throw new Error(`Upload failed! ${res.status})${errorMsg ? `: ${errorMsg}` : ''}`);
                    }).catch(() => {
                        throw new Error(`Upload failed! ${res.status})`);
                    });
                }
            }).catch(err => {
                console.error("Upload error:", err);
                alert("Upload failed!");
            });
    };
    img.src = processedBase64;
}

function bindModeButtonEvents() {
    modeButtons.forEach(button => {
        button.addEventListener('click', function (event) {
            event.preventDefault();
            const targetMode = this.dataset.mode;
            updateModeByValue(targetMode);
        });
    });
}

document.addEventListener('DOMContentLoaded', function () {
    modeButtons = document.querySelectorAll('a[data-mode]');
    tips = document.querySelectorAll('#tips > div');

    bindModeButtonEvents();

    Even_init();

    fetch('/NetWorkStatus')
        .then(response => {
            if (!response.ok) {
                throw new Error(`Request failed, status code:${response.status}`);
            }
            return response.text();
        })
        .then(data => {
            let serverMode = 'AP';
            const serverCode = parseInt(data);
            if (!isNaN(serverCode)) {
                serverMode = serverCode === 1 ? 'STA' : 'AP';
            }
            updateModeByValue(serverMode);
        })
        .catch(error => {
            console.error('Failed to obtain network status. Using default AP mode:', error);
            initializeMode();
        });
});